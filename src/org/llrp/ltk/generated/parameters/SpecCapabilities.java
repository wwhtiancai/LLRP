/*
 *
 * This file was generated by LLRP Code Generator
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit
 * for more information
 * Generated on: Mon Apr 10 16:16:15 CST 2017;
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.parameters;

import org.apache.log4j.Logger;

import org.jdom.Content;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.types.Bit;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.TLVParameter;
import org.llrp.ltk.types.TVParameter;
import org.llrp.ltk.types.UnsignedByte;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 *

See also

 */

/**
 *

See also
      .
 */
public class SpecCapabilities extends TLVParameter {
    public static final SignedShort TYPENUM = new SignedShort(356);
    private static final Logger LOGGER = Logger.getLogger(SpecCapabilities.class);
    protected Bit supportsClientRequestOpSpec;
    protected Bit supportsEventAndReportHolding;
    protected BitList reserved0 = new BitList(6);
    protected UnsignedShort clientRequestOpSpecTimeout;
    protected UnsignedByte maxPriorityLevelSupported;
    protected UnsignedByte maxNumSelectSpecs;
    protected UnsignedByte maxNumAntennaSpecsPerSelectSpec;
    protected UnsignedByte maxNumRfSpecsPerAntennaSpec;
    protected UnsignedByte maxNumAccessSpecs;
    protected UnsignedByte maxNumOperationSpecsPerAccessSpec;

    /**
     * empty constructor to create new parameter.
     */
    public SpecCapabilities() {
    }

    /**
     * Constructor to create parameter from binary encoded parameter
     * calls decodeBinary to decode parameter.
     * @param list to be decoded
     */
    public SpecCapabilities(LLRPBitList list) {
        decodeBinary(list);
    }

    /**
    * Constructor to create parameter from xml encoded parameter
    * calls decodeXML to decode parameter.
    * @param element to be decoded
    */
    public SpecCapabilities(Element element) throws InvalidLLRPMessageException {
        decodeXML(element);
    }

    /**
    * {@inheritDoc}
    */
    public LLRPBitList encodeBinarySpecific() {
        LLRPBitList resultBits = new LLRPBitList();

        if (supportsClientRequestOpSpec == null) {
            LOGGER.warn(" supportsClientRequestOpSpec not set");
            throw new MissingParameterException(
                " supportsClientRequestOpSpec not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(supportsClientRequestOpSpec.encodeBinary());

        if (supportsEventAndReportHolding == null) {
            LOGGER.warn(" supportsEventAndReportHolding not set");
            throw new MissingParameterException(
                " supportsEventAndReportHolding not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(supportsEventAndReportHolding.encodeBinary());
        resultBits.append(reserved0.encodeBinary());

        if (clientRequestOpSpecTimeout == null) {
            LOGGER.warn(" clientRequestOpSpecTimeout not set");
            throw new MissingParameterException(
                " clientRequestOpSpecTimeout not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(clientRequestOpSpecTimeout.encodeBinary());

        if (maxPriorityLevelSupported == null) {
            LOGGER.warn(" maxPriorityLevelSupported not set");
            throw new MissingParameterException(
                " maxPriorityLevelSupported not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxPriorityLevelSupported.encodeBinary());

        if (maxNumSelectSpecs == null) {
            LOGGER.warn(" maxNumSelectSpecs not set");
            throw new MissingParameterException(
                " maxNumSelectSpecs not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxNumSelectSpecs.encodeBinary());

        if (maxNumAntennaSpecsPerSelectSpec == null) {
            LOGGER.warn(" maxNumAntennaSpecsPerSelectSpec not set");
            throw new MissingParameterException(
                " maxNumAntennaSpecsPerSelectSpec not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxNumAntennaSpecsPerSelectSpec.encodeBinary());

        if (maxNumRfSpecsPerAntennaSpec == null) {
            LOGGER.warn(" maxNumRfSpecsPerAntennaSpec not set");
            throw new MissingParameterException(
                " maxNumRfSpecsPerAntennaSpec not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxNumRfSpecsPerAntennaSpec.encodeBinary());

        if (maxNumAccessSpecs == null) {
            LOGGER.warn(" maxNumAccessSpecs not set");
            throw new MissingParameterException(
                " maxNumAccessSpecs not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxNumAccessSpecs.encodeBinary());

        if (maxNumOperationSpecsPerAccessSpec == null) {
            LOGGER.warn(" maxNumOperationSpecsPerAccessSpec not set");
            throw new MissingParameterException(
                " maxNumOperationSpecsPerAccessSpec not set  for Parameter of Type SpecCapabilities");
        }

        resultBits.append(maxNumOperationSpecsPerAccessSpec.encodeBinary());

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Content encodeXML(String name, Namespace ns) {
        // element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
        ns = Namespace.getNamespace("", LLRPConstants.LLRPNAMESPACE);

        if (supportsClientRequestOpSpec == null) {
            LOGGER.warn(" supportsClientRequestOpSpec not set");
            throw new MissingParameterException(
                " supportsClientRequestOpSpec not set");
        } else {
            element.addContent(supportsClientRequestOpSpec.encodeXML(
                    "SupportsClientRequestOpSpec", ns));
        }

        if (supportsEventAndReportHolding == null) {
            LOGGER.warn(" supportsEventAndReportHolding not set");
            throw new MissingParameterException(
                " supportsEventAndReportHolding not set");
        } else {
            element.addContent(supportsEventAndReportHolding.encodeXML(
                    "SupportsEventAndReportHolding", ns));
        }

        //element.addContent(reserved0.encodeXML("reserved",ns));
        if (clientRequestOpSpecTimeout == null) {
            LOGGER.warn(" clientRequestOpSpecTimeout not set");
            throw new MissingParameterException(
                " clientRequestOpSpecTimeout not set");
        } else {
            element.addContent(clientRequestOpSpecTimeout.encodeXML(
                    "ClientRequestOpSpecTimeout", ns));
        }

        if (maxPriorityLevelSupported == null) {
            LOGGER.warn(" maxPriorityLevelSupported not set");
            throw new MissingParameterException(
                " maxPriorityLevelSupported not set");
        } else {
            element.addContent(maxPriorityLevelSupported.encodeXML(
                    "MaxPriorityLevelSupported", ns));
        }

        if (maxNumSelectSpecs == null) {
            LOGGER.warn(" maxNumSelectSpecs not set");
            throw new MissingParameterException(" maxNumSelectSpecs not set");
        } else {
            element.addContent(maxNumSelectSpecs.encodeXML(
                    "MaxNumSelectSpecs", ns));
        }

        if (maxNumAntennaSpecsPerSelectSpec == null) {
            LOGGER.warn(" maxNumAntennaSpecsPerSelectSpec not set");
            throw new MissingParameterException(
                " maxNumAntennaSpecsPerSelectSpec not set");
        } else {
            element.addContent(maxNumAntennaSpecsPerSelectSpec.encodeXML(
                    "MaxNumAntennaSpecsPerSelectSpec", ns));
        }

        if (maxNumRfSpecsPerAntennaSpec == null) {
            LOGGER.warn(" maxNumRfSpecsPerAntennaSpec not set");
            throw new MissingParameterException(
                " maxNumRfSpecsPerAntennaSpec not set");
        } else {
            element.addContent(maxNumRfSpecsPerAntennaSpec.encodeXML(
                    "MaxNumRfSpecsPerAntennaSpec", ns));
        }

        if (maxNumAccessSpecs == null) {
            LOGGER.warn(" maxNumAccessSpecs not set");
            throw new MissingParameterException(" maxNumAccessSpecs not set");
        } else {
            element.addContent(maxNumAccessSpecs.encodeXML(
                    "MaxNumAccessSpecs", ns));
        }

        if (maxNumOperationSpecsPerAccessSpec == null) {
            LOGGER.warn(" maxNumOperationSpecsPerAccessSpec not set");
            throw new MissingParameterException(
                " maxNumOperationSpecsPerAccessSpec not set");
        } else {
            element.addContent(maxNumOperationSpecsPerAccessSpec.encodeXML(
                    "MaxNumOperationSpecsPerAccessSpec", ns));
        }

        //parameters
        return element;
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary) {
        int position = 0 + TYPENUMBERLENGTH + PARAMETERTYPELENGTH; //change by wuwh 
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;
        supportsClientRequestOpSpec = new Bit(binary.subList(position,
                    Bit.length()));
        position += Bit.length();
        supportsEventAndReportHolding = new Bit(binary.subList(position,
                    Bit.length()));
        position += Bit.length();
        position += reserved0.length();
        clientRequestOpSpecTimeout = new UnsignedShort(binary.subList(
                    position, UnsignedShort.length()));
        position += UnsignedShort.length();
        maxPriorityLevelSupported = new UnsignedByte(binary.subList(position,
                    UnsignedByte.length()));
        position += UnsignedByte.length();
        maxNumSelectSpecs = new UnsignedByte(binary.subList(position,
                    UnsignedByte.length()));
        position += UnsignedByte.length();
        maxNumAntennaSpecsPerSelectSpec = new UnsignedByte(binary.subList(
                    position, UnsignedByte.length()));
        position += UnsignedByte.length();
        maxNumRfSpecsPerAntennaSpec = new UnsignedByte(binary.subList(
                    position, UnsignedByte.length()));
        position += UnsignedByte.length();
        maxNumAccessSpecs = new UnsignedByte(binary.subList(position,
                    UnsignedByte.length()));
        position += UnsignedByte.length();
        maxNumOperationSpecsPerAccessSpec = new UnsignedByte(binary.subList(
                    position, UnsignedByte.length()));
        position += UnsignedByte.length();
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(Element element) throws InvalidLLRPMessageException {
        List<Element> tempList = null;
        boolean atLeastOnce = false;

        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        temp = element.getChild("SupportsClientRequestOpSpec", ns);

        if (temp != null) {
            supportsClientRequestOpSpec = new Bit(temp);
        }

        element.removeChild("SupportsClientRequestOpSpec", ns);
        temp = element.getChild("SupportsEventAndReportHolding", ns);

        if (temp != null) {
            supportsEventAndReportHolding = new Bit(temp);
        }

        element.removeChild("SupportsEventAndReportHolding", ns);
        temp = element.getChild("ClientRequestOpSpecTimeout", ns);

        if (temp != null) {
            clientRequestOpSpecTimeout = new UnsignedShort(temp);
        }

        element.removeChild("ClientRequestOpSpecTimeout", ns);
        temp = element.getChild("MaxPriorityLevelSupported", ns);

        if (temp != null) {
            maxPriorityLevelSupported = new UnsignedByte(temp);
        }

        element.removeChild("MaxPriorityLevelSupported", ns);
        temp = element.getChild("MaxNumSelectSpecs", ns);

        if (temp != null) {
            maxNumSelectSpecs = new UnsignedByte(temp);
        }

        element.removeChild("MaxNumSelectSpecs", ns);
        temp = element.getChild("MaxNumAntennaSpecsPerSelectSpec", ns);

        if (temp != null) {
            maxNumAntennaSpecsPerSelectSpec = new UnsignedByte(temp);
        }

        element.removeChild("MaxNumAntennaSpecsPerSelectSpec", ns);
        temp = element.getChild("MaxNumRfSpecsPerAntennaSpec", ns);

        if (temp != null) {
            maxNumRfSpecsPerAntennaSpec = new UnsignedByte(temp);
        }

        element.removeChild("MaxNumRfSpecsPerAntennaSpec", ns);
        temp = element.getChild("MaxNumAccessSpecs", ns);

        if (temp != null) {
            maxNumAccessSpecs = new UnsignedByte(temp);
        }

        element.removeChild("MaxNumAccessSpecs", ns);
        temp = element.getChild("MaxNumOperationSpecsPerAccessSpec", ns);

        if (temp != null) {
            maxNumOperationSpecsPerAccessSpec = new UnsignedByte(temp);
        }

        element.removeChild("MaxNumOperationSpecsPerAccessSpec", ns);

        if (element.getChildren().size() > 0) {
            String message = "SpecCapabilities has unknown element " +
                ((Element) element.getChildren().get(0)).getName();
            throw new InvalidLLRPMessageException(message);
        }
    }

    //setters
    /**
    * set   supportsClientRequestOpSpec of type Bit .
    * @param   supportsClientRequestOpSpec to be set
    */
    public void setSupportsClientRequestOpSpec(
        final Bit supportsClientRequestOpSpec) {
        this.supportsClientRequestOpSpec = supportsClientRequestOpSpec;
    }

    /**
    * set   supportsEventAndReportHolding of type Bit .
    * @param   supportsEventAndReportHolding to be set
    */
    public void setSupportsEventAndReportHolding(
        final Bit supportsEventAndReportHolding) {
        this.supportsEventAndReportHolding = supportsEventAndReportHolding;
    }

    /**
    * set   clientRequestOpSpecTimeout of type UnsignedShort .
    * @param   clientRequestOpSpecTimeout to be set
    */
    public void setClientRequestOpSpecTimeout(
        final UnsignedShort clientRequestOpSpecTimeout) {
        this.clientRequestOpSpecTimeout = clientRequestOpSpecTimeout;
    }

    /**
    * set   maxPriorityLevelSupported of type UnsignedByte .
    * @param   maxPriorityLevelSupported to be set
    */
    public void setMaxPriorityLevelSupported(
        final UnsignedByte maxPriorityLevelSupported) {
        this.maxPriorityLevelSupported = maxPriorityLevelSupported;
    }

    /**
    * set   maxNumSelectSpecs of type UnsignedByte .
    * @param   maxNumSelectSpecs to be set
    */
    public void setMaxNumSelectSpecs(final UnsignedByte maxNumSelectSpecs) {
        this.maxNumSelectSpecs = maxNumSelectSpecs;
    }

    /**
    * set   maxNumAntennaSpecsPerSelectSpec of type UnsignedByte .
    * @param   maxNumAntennaSpecsPerSelectSpec to be set
    */
    public void setMaxNumAntennaSpecsPerSelectSpec(
        final UnsignedByte maxNumAntennaSpecsPerSelectSpec) {
        this.maxNumAntennaSpecsPerSelectSpec = maxNumAntennaSpecsPerSelectSpec;
    }

    /**
    * set   maxNumRfSpecsPerAntennaSpec of type UnsignedByte .
    * @param   maxNumRfSpecsPerAntennaSpec to be set
    */
    public void setMaxNumRfSpecsPerAntennaSpec(
        final UnsignedByte maxNumRfSpecsPerAntennaSpec) {
        this.maxNumRfSpecsPerAntennaSpec = maxNumRfSpecsPerAntennaSpec;
    }

    /**
    * set   maxNumAccessSpecs of type UnsignedByte .
    * @param   maxNumAccessSpecs to be set
    */
    public void setMaxNumAccessSpecs(final UnsignedByte maxNumAccessSpecs) {
        this.maxNumAccessSpecs = maxNumAccessSpecs;
    }

    /**
    * set   maxNumOperationSpecsPerAccessSpec of type UnsignedByte .
    * @param   maxNumOperationSpecsPerAccessSpec to be set
    */
    public void setMaxNumOperationSpecsPerAccessSpec(
        final UnsignedByte maxNumOperationSpecsPerAccessSpec) {
        this.maxNumOperationSpecsPerAccessSpec = maxNumOperationSpecsPerAccessSpec;
    }

    // end setter

    //getters
    /**
    * get   supportsClientRequestOpSpec of type Bit.
    * @return   type Bit to be set
    */
    public Bit getSupportsClientRequestOpSpec() {
        return this.supportsClientRequestOpSpec;
    }

    /**
    * get   supportsEventAndReportHolding of type Bit.
    * @return   type Bit to be set
    */
    public Bit getSupportsEventAndReportHolding() {
        return this.supportsEventAndReportHolding;
    }

    /**
    * get   clientRequestOpSpecTimeout of type UnsignedShort.
    * @return   type UnsignedShort to be set
    */
    public UnsignedShort getClientRequestOpSpecTimeout() {
        return this.clientRequestOpSpecTimeout;
    }

    /**
    * get   maxPriorityLevelSupported of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxPriorityLevelSupported() {
        return this.maxPriorityLevelSupported;
    }

    /**
    * get   maxNumSelectSpecs of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxNumSelectSpecs() {
        return this.maxNumSelectSpecs;
    }

    /**
    * get   maxNumAntennaSpecsPerSelectSpec of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxNumAntennaSpecsPerSelectSpec() {
        return this.maxNumAntennaSpecsPerSelectSpec;
    }

    /**
    * get   maxNumRfSpecsPerAntennaSpec of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxNumRfSpecsPerAntennaSpec() {
        return this.maxNumRfSpecsPerAntennaSpec;
    }

    /**
    * get   maxNumAccessSpecs of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxNumAccessSpecs() {
        return this.maxNumAccessSpecs;
    }

    /**
    * get   maxNumOperationSpecsPerAccessSpec of type UnsignedByte.
    * @return   type UnsignedByte to be set
    */
    public UnsignedByte getMaxNumOperationSpecsPerAccessSpec() {
        return this.maxNumOperationSpecsPerAccessSpec;
    }

    // end getters

    //add methods

    // end add

    /**
    * For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
    * @return Integer always zero
    */
    public static Integer length() {
        return 0;
    }

    /**
    * {@inheritDoc}
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }

    /**
    * {@inheritDoc}
    */
    public String getName() {
        return "SpecCapabilities";
    }

    /**
    * return string representation. All field values but no parameters are included
    * @return String
    */
    public String toString() {
        String result = "SpecCapabilities: ";
        result += ", supportsClientRequestOpSpec: ";
        result += supportsClientRequestOpSpec;
        result += ", supportsEventAndReportHolding: ";
        result += supportsEventAndReportHolding;

        result += ", clientRequestOpSpecTimeout: ";
        result += clientRequestOpSpecTimeout;
        result += ", maxPriorityLevelSupported: ";
        result += maxPriorityLevelSupported;
        result += ", maxNumSelectSpecs: ";
        result += maxNumSelectSpecs;
        result += ", maxNumAntennaSpecsPerSelectSpec: ";
        result += maxNumAntennaSpecsPerSelectSpec;
        result += ", maxNumRfSpecsPerAntennaSpec: ";
        result += maxNumRfSpecsPerAntennaSpec;
        result += ", maxNumAccessSpecs: ";
        result += maxNumAccessSpecs;
        result += ", maxNumOperationSpecsPerAccessSpec: ";
        result += maxNumOperationSpecsPerAccessSpec;
        result = result.replaceFirst(", ", "");

        return result;
    }
}
