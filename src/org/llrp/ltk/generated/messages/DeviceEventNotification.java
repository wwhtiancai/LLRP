/*
*
* This file was generated by LLRP Code Generator
* see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit
* for more information
* Generated on: Mon Apr 10 16:16:13 CST 2017;
*
*/

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package org.llrp.ltk.generated.messages;

import org.apache.log4j.Logger;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;

import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.exceptions.MissingParameterException;
import org.llrp.ltk.generated.LLRPConstants;
import org.llrp.ltk.generated.parameters.AntennaSpecEvent;
import org.llrp.ltk.generated.parameters.AntennaStatusEvent;
import org.llrp.ltk.generated.parameters.ConnectionAttemptEvent;
import org.llrp.ltk.generated.parameters.GPIEvent;
import org.llrp.ltk.generated.parameters.SelectSpecEvent;
import org.llrp.ltk.generated.parameters.UTCTimestamp;
import org.llrp.ltk.types.BitList;
import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.LLRPMessage;
import org.llrp.ltk.types.SignedShort;
import org.llrp.ltk.types.UnsignedInteger;
import org.llrp.ltk.types.UnsignedShort;

import java.util.LinkedList;
import java.util.List;


/**
 *

See also

 */
public class DeviceEventNotification extends LLRPMessage {
    public static final SignedShort TYPENUM = new SignedShort(302);
    private static final Logger LOGGER = Logger.getLogger(DeviceEventNotification.class);
    public static final String RESPONSETYPE = "";
    protected UTCTimestamp uTCTimestamp;
    protected GPIEvent gPIEvent;
    protected SelectSpecEvent selectSpecEvent;
    protected AntennaSpecEvent antennaSpecEvent;
    protected AntennaStatusEvent antennaStatusEvent;
    protected ConnectionAttemptEvent connectionAttemptEvent;

    /**
     * empty constructor to create new message
     * with LLRP version set to 1.0 (0x1).
     */
    public DeviceEventNotification() {
        //		setVersion(new BitList(0,0,1));
        setVersion(new BitList(0, 0, 0, 0, 0, 0, 0, 1)); // change by wuwh 
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param list to be decoded
     */
    public DeviceEventNotification(final LLRPBitList list)
        throws InvalidLLRPMessageException {
        decodeBinary(list.toByteArray());
    }

    /**
     * Constructor to create message from binary encoded message
     * calls decodeBinary to decode message.
     * @param byteArray representing message
     */
    public DeviceEventNotification(final byte[] byteArray)
        throws InvalidLLRPMessageException {
        decodeBinary(byteArray);
    }

    /**
    * Constructor to create message from xml encoded message
    * calls decodeXML to decode message.
    * @param document to be decoded
    */
    public DeviceEventNotification(final Document document)
        throws InvalidLLRPMessageException {
        decodeXML(document);
    }

    /**
    * {@inheritDoc}
    */
    protected LLRPBitList encodeBinarySpecific()
        throws InvalidLLRPMessageException {
        LLRPBitList resultBits = new LLRPBitList();

        if (uTCTimestamp == null) {
            // single parameter, may not be null
            LOGGER.warn(" uTCTimestamp not set");
            throw new InvalidLLRPMessageException(" uTCTimestamp not set");
        } else {
            resultBits.append(uTCTimestamp.encodeBinary());
        }

        if (gPIEvent == null) {
            // optional parameter, may be null
            LOGGER.info(" gPIEvent not set");
        } else {
            resultBits.append(gPIEvent.encodeBinary());
        }

        if (selectSpecEvent == null) {
            // optional parameter, may be null
            LOGGER.info(" selectSpecEvent not set");
        } else {
            resultBits.append(selectSpecEvent.encodeBinary());
        }

        if (antennaSpecEvent == null) {
            // optional parameter, may be null
            LOGGER.info(" antennaSpecEvent not set");
        } else {
            resultBits.append(antennaSpecEvent.encodeBinary());
        }

        if (antennaStatusEvent == null) {
            // optional parameter, may be null
            LOGGER.info(" antennaStatusEvent not set");
        } else {
            resultBits.append(antennaStatusEvent.encodeBinary());
        }

        if (connectionAttemptEvent == null) {
            // optional parameter, may be null
            LOGGER.info(" connectionAttemptEvent not set");
        } else {
            resultBits.append(connectionAttemptEvent.encodeBinary());
        }

        return resultBits;
    }

    /**
    * {@inheritDoc}
    */
    public Document encodeXML() throws InvalidLLRPMessageException {
        try {
            Namespace ns = Namespace.getNamespace("",
                    LLRPConstants.LLRPNAMESPACE);

            Element root = new Element("DeviceEventNotification", ns);
            //	Element root = new Element("DeviceEventNotification");
            root.addNamespaceDeclaration(Namespace.getNamespace("llrp",
                    LLRPConstants.LLRPNAMESPACE));

            if (version == null) {
                throw new InvalidLLRPMessageException("Version not set");
            } else {
                root.setAttribute("Version", version.toInteger().toString());
            }

            if (messageID == null) {
                throw new InvalidLLRPMessageException("MessageID not set");
            } else {
                root.setAttribute("MessageID", messageID.toString(10));
            }

            //parameters
            if (uTCTimestamp == null) {
                LOGGER.info("uTCTimestamp not set");
                throw new MissingParameterException("uTCTimestamp not set");
            } else {
                root.addContent(uTCTimestamp.encodeXML(
                        uTCTimestamp.getClass().getSimpleName(), ns));
            }

            if (gPIEvent == null) {
                LOGGER.info("gPIEvent not set");
            } else {
                root.addContent(gPIEvent.encodeXML(gPIEvent.getClass()
                                                           .getSimpleName(), ns));
            }

            if (selectSpecEvent == null) {
                LOGGER.info("selectSpecEvent not set");
            } else {
                root.addContent(selectSpecEvent.encodeXML(
                        selectSpecEvent.getClass().getSimpleName(), ns));
            }

            if (antennaSpecEvent == null) {
                LOGGER.info("antennaSpecEvent not set");
            } else {
                root.addContent(antennaSpecEvent.encodeXML(
                        antennaSpecEvent.getClass().getSimpleName(), ns));
            }

            if (antennaStatusEvent == null) {
                LOGGER.info("antennaStatusEvent not set");
            } else {
                root.addContent(antennaStatusEvent.encodeXML(
                        antennaStatusEvent.getClass().getSimpleName(), ns));
            }

            if (connectionAttemptEvent == null) {
                LOGGER.info("connectionAttemptEvent not set");
            } else {
                root.addContent(connectionAttemptEvent.encodeXML(
                        connectionAttemptEvent.getClass().getSimpleName(), ns));
            }

            Document doc = new Document(root);

            if (isValidXMLMessage(doc, LLRPConstants.LLRPMESSAGESCHEMAPATH)) {
                return doc;
            } else {
                return null;
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    /**
    * {@inheritDoc}
    */
    protected void decodeBinarySpecific(LLRPBitList binary)
        throws InvalidLLRPMessageException {
        int position = 0;
        int tempByteLength;
        int tempLength = 0;
        int count;
        SignedShort type;
        int fieldCount;

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.warn(
                "DeviceEventNotification misses non optional parameter of type UTCTimestamp");
            throw new InvalidLLRPMessageException(
                "DeviceEventNotification misses non optional parameter of type UTCTimestamp");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = uTCTimestamp.length();
        }

        if ((type != null) && type.equals(UTCTimestamp.TYPENUM)) {
            uTCTimestamp = new UTCTimestamp(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " uTCTimestamp is instantiated with UTCTimestamp with length" +
                tempLength);
        } else {
            LOGGER.warn(
                "DeviceEventNotification misses non optional parameter of type UTCTimestamp");
            throw new InvalidLLRPMessageException(
                "DeviceEventNotification misses non optional parameter of type UTCTimestamp");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type GPIEvent");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = gPIEvent.length();
        }

        if ((type != null) && type.equals(GPIEvent.TYPENUM)) {
            gPIEvent = new GPIEvent(binary.subList(position, tempLength));
            position += tempLength;
            LOGGER.debug(" gPIEvent is instantiated with GPIEvent with length" +
                tempLength);
        } else {
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type GPIEvent");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type SelectSpecEvent");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = selectSpecEvent.length();
        }

        if ((type != null) && type.equals(SelectSpecEvent.TYPENUM)) {
            selectSpecEvent = new SelectSpecEvent(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " selectSpecEvent is instantiated with SelectSpecEvent with length" +
                tempLength);
        } else {
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type SelectSpecEvent");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type AntennaSpecEvent");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = antennaSpecEvent.length();
        }

        if ((type != null) && type.equals(AntennaSpecEvent.TYPENUM)) {
            antennaSpecEvent = new AntennaSpecEvent(binary.subList(position,
                        tempLength));
            position += tempLength;
            LOGGER.debug(
                " antennaSpecEvent is instantiated with AntennaSpecEvent with length" +
                tempLength);
        } else {
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type AntennaSpecEvent");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type AntennaStatusEvent");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = antennaStatusEvent.length();
        }

        if ((type != null) && type.equals(AntennaStatusEvent.TYPENUM)) {
            antennaStatusEvent = new AntennaStatusEvent(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " antennaStatusEvent is instantiated with AntennaStatusEvent with length" +
                tempLength);
        } else {
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type AntennaStatusEvent");
        }

        // look ahead to see type
        // may be optional or exactly once
        type = null;
        tempByteLength = 0;
        tempLength = 0;

        try {
            // if first bit is one it is a TV Parameter
            if (binary.get(position)) {
                // do not take the first bit as it is always 1
                type = new SignedShort(binary.subList(position + 1, 7));
            } else {
                //type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
                //tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
                //tempLength=8*tempByteLength;
                type = new SignedShort(binary.subList(position,
                            PARAMETERTYPELENGTH)); //change by wuwh
                tempByteLength = new UnsignedShort(binary.subList(position +
                            PARAMETERTYPELENGTH, UnsignedShort.length())).toShort(); //change by wuwh		
                tempLength = 8 * (tempByteLength + 4); //change by wuwh
            }
        } catch (IllegalArgumentException le) {
            // if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type ConnectionAttemptEvent");
        }

        if (binary.get(position)) {
            // length can statically be determined for TV Parameters
            tempLength = connectionAttemptEvent.length();
        }

        if ((type != null) && type.equals(ConnectionAttemptEvent.TYPENUM)) {
            connectionAttemptEvent = new ConnectionAttemptEvent(binary.subList(
                        position, tempLength));
            position += tempLength;
            LOGGER.debug(
                " connectionAttemptEvent is instantiated with ConnectionAttemptEvent with length" +
                tempLength);
        } else {
            LOGGER.info(
                "DeviceEventNotification misses optional parameter of type ConnectionAttemptEvent");
        }
    }

    /**
    * {@inheritDoc}
    */
    public void decodeXML(final Document document)
        throws InvalidLLRPMessageException {
        Element temp = null;

        // child element are always in default LLRP namespace
        Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);

        try {
            isValidXMLMessage(document, LLRPConstants.LLRPMESSAGESCHEMAPATH);

            Element root = (Element) document.getRootElement().clone();
            List<Element> tempList = null;

            // the version field is always 3 bit long 
            // if the version attribute is not set in the LTK-XML message,
            // it is set to version 001
            String versionAttribute = root.getAttributeValue("Version");

            if (versionAttribute != null) {
                version = new BitList(8); //change by wuwh 3 to 8
                version.setValue(new Integer(versionAttribute));
            } else {
                version = new BitList(0, 0, 0, 0, 0, 0, 0, 1); //change by wuwh 
            }

            messageID = new UnsignedInteger(root.getAttributeValue("MessageID"));

            //parameter - not choices - no special actions needed
            temp = root.getChild("UTCTimestamp", ns);

            if (temp != null) {
                uTCTimestamp = new UTCTimestamp(temp);
                LOGGER.info(
                    "setting parameter uTCTimestamp for parameter DeviceEventNotification");
            } else {
                LOGGER.warn(
                    "DeviceEventNotification misses non optional parameter of type uTCTimestamp");
                throw new MissingParameterException(
                    "DeviceEventNotification misses non optional parameter of type uTCTimestamp");
            }

            root.removeChild("UTCTimestamp", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("GPIEvent", ns);

            if (temp != null) {
                gPIEvent = new GPIEvent(temp);
                LOGGER.info(
                    "setting parameter gPIEvent for parameter DeviceEventNotification");
            } else {
                LOGGER.info(
                    "DeviceEventNotification misses optional parameter of type gPIEvent");
            }

            root.removeChild("GPIEvent", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("SelectSpecEvent", ns);

            if (temp != null) {
                selectSpecEvent = new SelectSpecEvent(temp);
                LOGGER.info(
                    "setting parameter selectSpecEvent for parameter DeviceEventNotification");
            } else {
                LOGGER.info(
                    "DeviceEventNotification misses optional parameter of type selectSpecEvent");
            }

            root.removeChild("SelectSpecEvent", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("AntennaSpecEvent", ns);

            if (temp != null) {
                antennaSpecEvent = new AntennaSpecEvent(temp);
                LOGGER.info(
                    "setting parameter antennaSpecEvent for parameter DeviceEventNotification");
            } else {
                LOGGER.info(
                    "DeviceEventNotification misses optional parameter of type antennaSpecEvent");
            }

            root.removeChild("AntennaSpecEvent", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("AntennaStatusEvent", ns);

            if (temp != null) {
                antennaStatusEvent = new AntennaStatusEvent(temp);
                LOGGER.info(
                    "setting parameter antennaStatusEvent for parameter DeviceEventNotification");
            } else {
                LOGGER.info(
                    "DeviceEventNotification misses optional parameter of type antennaStatusEvent");
            }

            root.removeChild("AntennaStatusEvent", ns);
            //parameter - not choices - no special actions needed
            temp = root.getChild("ConnectionAttemptEvent", ns);

            if (temp != null) {
                connectionAttemptEvent = new ConnectionAttemptEvent(temp);
                LOGGER.info(
                    "setting parameter connectionAttemptEvent for parameter DeviceEventNotification");
            } else {
                LOGGER.info(
                    "DeviceEventNotification misses optional parameter of type connectionAttemptEvent");
            }

            root.removeChild("ConnectionAttemptEvent", ns);

            if (root.getChildren().size() > 0) {
                String message = "DeviceEventNotification has unknown element " +
                    ((Element) root.getChildren().get(0)).getName();
                throw new InvalidLLRPMessageException(message);
            }
        } catch (IllegalArgumentException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        } catch (MissingParameterException e) {
            throw new InvalidLLRPMessageException(e.getMessage());
        }
    }

    //setters

    /**
    * set uTCTimestamp of type UTCTimestamp.
    * @param  uTCTimestamp to be set
    */
    public void setUTCTimestamp(final UTCTimestamp uTCTimestamp) {
        this.uTCTimestamp = uTCTimestamp;
    }

    /**
    * set gPIEvent of type GPIEvent.
    * @param  gPIEvent to be set
    */
    public void setGPIEvent(final GPIEvent gPIEvent) {
        this.gPIEvent = gPIEvent;
    }

    /**
    * set selectSpecEvent of type SelectSpecEvent.
    * @param  selectSpecEvent to be set
    */
    public void setSelectSpecEvent(final SelectSpecEvent selectSpecEvent) {
        this.selectSpecEvent = selectSpecEvent;
    }

    /**
    * set antennaSpecEvent of type AntennaSpecEvent.
    * @param  antennaSpecEvent to be set
    */
    public void setAntennaSpecEvent(final AntennaSpecEvent antennaSpecEvent) {
        this.antennaSpecEvent = antennaSpecEvent;
    }

    /**
    * set antennaStatusEvent of type AntennaStatusEvent.
    * @param  antennaStatusEvent to be set
    */
    public void setAntennaStatusEvent(
        final AntennaStatusEvent antennaStatusEvent) {
        this.antennaStatusEvent = antennaStatusEvent;
    }

    /**
    * set connectionAttemptEvent of type ConnectionAttemptEvent.
    * @param  connectionAttemptEvent to be set
    */
    public void setConnectionAttemptEvent(
        final ConnectionAttemptEvent connectionAttemptEvent) {
        this.connectionAttemptEvent = connectionAttemptEvent;
    }

    // end setter

    //getters

    /**
    * get uTCTimestamp of type UTCTimestamp .
    * @return  UTCTimestamp
    */
    public UTCTimestamp getUTCTimestamp() {
        return uTCTimestamp;
    }

    /**
    * get gPIEvent of type GPIEvent .
    * @return  GPIEvent
    */
    public GPIEvent getGPIEvent() {
        return gPIEvent;
    }

    /**
    * get selectSpecEvent of type SelectSpecEvent .
    * @return  SelectSpecEvent
    */
    public SelectSpecEvent getSelectSpecEvent() {
        return selectSpecEvent;
    }

    /**
    * get antennaSpecEvent of type AntennaSpecEvent .
    * @return  AntennaSpecEvent
    */
    public AntennaSpecEvent getAntennaSpecEvent() {
        return antennaSpecEvent;
    }

    /**
    * get antennaStatusEvent of type AntennaStatusEvent .
    * @return  AntennaStatusEvent
    */
    public AntennaStatusEvent getAntennaStatusEvent() {
        return antennaStatusEvent;
    }

    /**
    * get connectionAttemptEvent of type ConnectionAttemptEvent .
    * @return  ConnectionAttemptEvent
    */
    public ConnectionAttemptEvent getConnectionAttemptEvent() {
        return connectionAttemptEvent;
    }

    // end getters

    //add methods

    // end add
    @Override
    public String getResponseType() {
        return RESPONSETYPE;
    }

    @Override
    public String getName() {
        return "DeviceEventNotification";
    }

    /**
    * return uniuque type number.
    * @return SignedShort holding unique type number
    */
    public SignedShort getTypeNum() {
        return TYPENUM;
    }
}
